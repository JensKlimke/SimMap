#include <memory>

//
// Created by Jens Klimke on 2019-05-01.
// TODO: clean up the concept. I think the lane section sequence is probably not necessary:
//  Neighbors can be directly generated by parsing the odr, same for links.


#include "ODRAdapter.h"
#include "ODREdge.h"
#include "ODRRoad.h"
#include "ODRJunction.h"
#include "ODRObject.h"
#include "LaneSectionSequence.h"

#include <graph/Graph.h>
#include <iostream>
#include <memory>
#include <base/definitions.h>
#include <base/functions.h>


// function definitions
void parseCurve(ODRRoad *road, const odr1_5::t_road &r);

void parseLaneOffset(ODRRoad *road, const odr1_5::t_road &r);

void parseJunction(ODRJunction *junc, const odr1_5::t_junction &j,
                   std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                   std::map<std::string, std::shared_ptr<ODREdge>> &edges);

void parseLaneSections(std::map<std::string, std::shared_ptr<ODREdge>> &edges,
                       const odr1_5::t_road &rd,
                       const std::map<std::string, std::shared_ptr<ODRRoad>> &roads);

void parseLinks(const odr1_5::OpenDRIVE *odr,
                std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                const std::map<std::string, std::shared_ptr<ODRJunction>> &juncs);

void parseSignals(ODRRoad *road, const odr1_5::t_road &rd);


namespace simmap {
namespace odra {

    void ODRAdapter::loadFile(const std::string &filename) {

        // create indexes
        std::map<std::string, std::shared_ptr<ODREdge>> _edges;
        std::map<std::string, std::shared_ptr<ODRRoad>> _roads{};
        std::map<std::string, std::shared_ptr<ODRJunction>> _juncs{};

        // load ODR file
        odr::OpenDRIVEFile _file;
        odr::loadFile(filename, _file);

        // create roads
        for (const auto &r : _file.OpenDRIVE1_5->sub_road) {

            // create road object
            auto ptr = std::make_shared<ODRRoad>();

            // register road to index and network
            _roads[*r._id] = ptr;
            _roadNetwork[*r._id] = ptr;

            // set ID
            ptr->_id = *r._id;

            // parse curve and lane offset
            parseCurve(ptr.get(), r);
            parseLaneOffset(ptr.get(), r);

            // parse edges
            parseLaneSections(_edges, r, _roads);

            // parse objects
            parseSignals(ptr.get(), r);

        }

        // create junctions
        for (const auto &j : _file.OpenDRIVE1_5->sub_junction) {

            // create road object
            auto ptr = std::make_shared<ODRJunction>();
            parseJunction(ptr.get(), j, _roads, _edges);

            // register junction to index
            _juncs[*j._id] = ptr;

        }

        // parse road links
        parseLinks(_file.OpenDRIVE1_5.get(), _roads, _juncs);


        // generate network (edges and roads)
        this->_laneNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_edges)
        )};
        this->_roadNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_roads)
        )};


    }


    std::ostream &ODRAdapter::streamTo(std::ostream &os) const {

        double xMin = INFINITY, xMax = -INFINITY, yMin = INFINITY, yMax = -INFINITY;


        os << "{ \"data\" : [ ";

        size_t i = 0;
        for (const auto &r : _roadNetwork) {

            // get rad and curves
            auto road = reinterpret_cast<ODRRoad *>(r.second.get());
            auto c = road->_curve.get();

            // start data set
            os << (i++ == 0 ? "" : ", ") << R"({"name" : ")" << r.first << R"(", "type" : "ref", "points" : [ )";

            // calculate points
            auto s = c->steps(0.1, 10.0);
            auto pts = (*c)(s);


            // iterate over points
            size_t j = 0;
            for (const auto &pt : pts) {

                // write position
                os << (j++ == 0 ? "" : ", ") << "{ \"x\" : " << pt.position.x() << ", \"y\" : " << pt.position.y()
                   << ", \"phi\" : " << pt.angle << " }\n";

                // save boundaries
                xMin = xMin <= pt.position.x() ? xMin : pt.position.x();
                xMax = xMax >= pt.position.x() ? xMax : pt.position.x();
                yMin = yMin <= pt.position.y() ? yMin : pt.position.y();
                yMax = yMax >= pt.position.y() ? yMax : pt.position.y();

            }

            os << " ] }\n ";

        }

        /*i = 0;
        for(const auto &o : this->_offsets) {

            os << (i++ == 0 ? "" : ", ") << R"({"name" : ")" << o.first << R"(", "type" : "offset", "points" : [ )";

            // get curve and steps
            auto c = _curves.at(o.first);
            auto s = c->steps(1.0, 10.0);

            // calculate points
            auto pts = (*c)(s);
            auto offs = (*o.second)(s);

            // iterate over points
            size_t j = 0;
            for(auto pt : pts) {

                // add offset
                pt.position = base::toGlobal(pt, {0.0, offs(j), 0.0});

                // write position
                os << (j++ == 0 ? "" : ", ") << "{ \"x\" : " << pt.position.x() << ", \"y\" : " << pt.position.y()
                   << ", \"phi\" : " << pt.angle << " }\n";

                // save boundaries
                xMin = xMin <= pt.position.x() ? xMin : pt.position.x();
                xMax = xMax >= pt.position.x() ? xMax : pt.position.x();
                yMin = yMin <= pt.position.y() ? yMin : pt.position.y();
                yMax = yMax >= pt.position.y() ? yMax : pt.position.y();

            }

            os << " ] }\n ";

        }*/

        // write meta data
        os << R"( ], "meta" : { "xMin" : )" << xMin << ", \"xMax\" : " << xMax
           << ", \"yMin\" : " << yMin << ", \"yMax\" : " << yMax << "  } }";

        return os;

    }

}}
