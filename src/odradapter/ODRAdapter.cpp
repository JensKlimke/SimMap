#include <memory>

//
// Copyright (c) 2019 Jens Klimke <jens.klimke@rwth-aachen.de>. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Created by Jens Klimke on 2019-05-01.
// TODO: clean up the concept. I think the lane section sequence is probably not necessary:
//  Neighbors can be directly generated by parsing the odr, same for links.


#include "ODRAdapter.h"
#include "ODREdge.h"
#include "ODRRoad.h"
#include "ODRJunction.h"
#include "ODRObject.h"
#include "LaneSectionSequence.h"

#include <graph/Graph.h>
#include <iostream>
#include <memory>
#include <base/definitions.h>
#include <base/functions.h>


// function definitions
void parseCurve(ODRRoad *road, const odr1_5::t_road &r);

void parseLaneOffset(ODRRoad *road, const odr1_5::t_road &r);

void parseJunction(ODRJunction *junc, const odr1_5::t_junction &j,
                   std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                   std::map<std::string, std::shared_ptr<ODREdge>> &edges);

void parseLaneSections(std::map<std::string, std::shared_ptr<ODREdge>> &edges,
                       const odr1_5::t_road &rd,
                       const std::map<std::string, std::shared_ptr<ODRRoad>> &roads);

void parseLinks(const odr1_5::OpenDRIVE *odr,
                std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                const std::map<std::string, std::shared_ptr<ODRJunction>> &juncs);

void parseSignals(ODRRoad *road, const odr1_5::t_road &rd);


namespace simmap {
namespace odra {

    void ODRAdapter::loadFile(const std::string &filename) {

        // create indexes
        std::map<std::string, std::shared_ptr<ODREdge>> _edges;
        std::map<std::string, std::shared_ptr<ODRRoad>> _roads{};
        std::map<std::string, std::shared_ptr<ODRJunction>> _juncs{};

        // load ODR file
        odr::OpenDRIVEFile _file;
        odr::loadFile(filename, _file);

        // create roads
        for (const auto &r : _file.OpenDRIVE1_5->sub_road) {

            // create road object
            auto ptr = std::make_shared<ODRRoad>();

            // register road to index and network
            _roads[*r._id] = ptr;
            _roadNetwork[*r._id] = ptr;

            // set ID
            ptr->_id = *r._id;

            // parse curve and lane offset
            parseCurve(ptr.get(), r);
            parseLaneOffset(ptr.get(), r);

            // parse edges
            parseLaneSections(_edges, r, _roads);

            // parse objects
            parseSignals(ptr.get(), r);

        }

        // create junctions
        for (const auto &j : _file.OpenDRIVE1_5->sub_junction) {

            // create road object
            auto ptr = std::make_shared<ODRJunction>();
            parseJunction(ptr.get(), j, _roads, _edges);

            // register junction to index
            _juncs[*j._id] = ptr;

        }

        // parse road links
        parseLinks(_file.OpenDRIVE1_5.get(), _roads, _juncs);


        // generate network (edges and roads)
        this->_laneNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_edges)
        )};
        this->_roadNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_roads)
        )};


    }

}}
