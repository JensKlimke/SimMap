#include <memory>

//
// Copyright (c) 2019 Jens Klimke <jens.klimke@rwth-aachen.de>. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Created by Jens Klimke on 2019-05-01.
// TODO: clean up the concept. I think the lane section sequence is probably not necessary:
//  Neighbors can be directly generated by parsing the odr, same for links.


#include "ODRAdapter.h"
#include "ODREdge.h"
#include "ODRRoad.h"
#include "ODRJunction.h"
#include "ODRObject.h"
#include "LaneSectionSequence.h"

#include <graph/Graph.h>
#include <iostream>
#include <memory>
#include <base/definitions.h>
#include <base/functions.h>


// function definitions
void parseCurve(ODRRoad *road, const odr1_5::t_road &r);

void parseLaneOffset(ODRRoad *road, const odr1_5::t_road &r);

void parseJunction(ODRJunction *junc, const odr1_5::t_junction &j,
                   std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                   std::map<std::string, std::shared_ptr<ODREdge>> &edges);

void parseLaneSections(std::map<std::string, std::shared_ptr<ODREdge>> &edges,
                       const odr1_5::t_road &rd,
                       const std::map<std::string, std::shared_ptr<ODRRoad>> &roads);

void parseLinks(const odr1_5::OpenDRIVE *odr,
                std::map<std::string, std::shared_ptr<ODRRoad>> &roads,
                const std::map<std::string, std::shared_ptr<ODRJunction>> &juncs);

void parseSignals(ODRRoad *road, const odr1_5::t_road &rd);


namespace simmap {
namespace odra {

    void ODRAdapter::loadFile(const std::string &filename) {

        // create indexes
        std::map<std::string, std::shared_ptr<ODREdge>> _edges;
        std::map<std::string, std::shared_ptr<ODRRoad>> _roads{};
        std::map<std::string, std::shared_ptr<ODRJunction>> _juncs{};

        // load ODR file
        odr::OpenDRIVEFile _file;
        odr::loadFile(filename, _file);

        // create roads
        for (const auto &r : _file.OpenDRIVE1_5->sub_road) {

            // create road object
            auto ptr = std::make_shared<ODRRoad>();

            // register road to index and network
            _roads[*r._id] = ptr;
            _roadNetwork[*r._id] = ptr;

            // set ID
            ptr->_id = *r._id;

            // parse curve and lane offset
            parseCurve(ptr.get(), r);
            parseLaneOffset(ptr.get(), r);

            // parse edges
            parseLaneSections(_edges, r, _roads);

            // parse objects
            parseSignals(ptr.get(), r);

        }

        // create junctions
        for (const auto &j : _file.OpenDRIVE1_5->sub_junction) {

            // create road object
            auto ptr = std::make_shared<ODRJunction>();
            parseJunction(ptr.get(), j, _roads, _edges);

            // register junction to index
            _juncs[*j._id] = ptr;

        }

        // parse road links
        parseLinks(_file.OpenDRIVE1_5.get(), _roads, _juncs);


        // generate network (edges and roads)
        this->_laneNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_edges)
        )};
        this->_roadNetwork = graph::Graph{std::move(
                *reinterpret_cast<std::map<std::string, std::shared_ptr<graph::Edge>> *>(&_roads)
        )};


    }


    std::ostream &ODRAdapter::streamTo(std::ostream &os) const {

        double xMin = INFINITY, xMax = -INFINITY, yMin = INFINITY, yMax = -INFINITY;


        os << "{ \"data\" : [ ";

        size_t i = 0;
        for (const auto &r : _roadNetwork) {

            // get rad and curves
            auto road = reinterpret_cast<ODRRoad *>(r.second.get());
            auto c = road->_curve.get();

            // start data set
            os << (i++ == 0 ? "" : ", ") << R"({"name" : ")" << r.first << R"(", "type" : "ref", "points" : [ )";

            // calculate points
            auto s = c->steps(0.1, 10.0);
            auto pts = (*c)(s);


            // iterate over points
            size_t j = 0;
            for (const auto &pt : pts) {

                // write position
                os << (j++ == 0 ? "" : ", ") << "{ \"x\" : " << pt.position.x() << ", \"y\" : " << pt.position.y()
                   << ", \"phi\" : " << pt.angle << " }\n";

                // save boundaries
                xMin = xMin <= pt.position.x() ? xMin : pt.position.x();
                xMax = xMax >= pt.position.x() ? xMax : pt.position.x();
                yMin = yMin <= pt.position.y() ? yMin : pt.position.y();
                yMax = yMax >= pt.position.y() ? yMax : pt.position.y();

            }

            os << " ] }\n ";

        }


        for (const auto &e : _laneNetwork) {

            // get rad and curves
            auto edge = reinterpret_cast<ODREdge *>(e.second.get());

            // start data set
            os << (i++ == 0 ? "" : ", ") << R"({"name" : ")" << e.first << R"(", "type" : "line", "points" : [ )";

            // calculate points
            auto pts = base::maxspace(0.0, edge->length(), 5.0);

            // iterate over points
            for (size_t j = 0; j < pts.size(); ++j) {

                auto s = pts(j);

                // inner line
                auto pt = edge->position(s, def::Reference::INNER, 0.0);

                // write position
                os << (j++ == 0 ? "" : ", ") << "{ \"x\" : " << pt.position.x() << ", \"y\" : " << pt.position.y()
                   << ", \"phi\" : " << pt.angle << " }\n";

                // save boundaries
                xMin = xMin <= pt.position.x() ? xMin : pt.position.x();
                xMax = xMax >= pt.position.x() ? xMax : pt.position.x();
                yMin = yMin <= pt.position.y() ? yMin : pt.position.y();
                yMax = yMax >= pt.position.y() ? yMax : pt.position.y();

            }

            os << " ] }\n ";


            // start data set
            os << (i++ == 0 ? "" : ", ") << R"({"name" : ")" << e.first << R"(", "type" : "line", "points" : [ )";

            // iterate over points
            for (size_t j = 0; j < pts.size(); ++j) {

                auto s = pts(j);

                // outer line
                auto pt = edge->position(s, def::Reference::OUTER, 0.0);

                // write position
                os << (j++ == 0 ? "" : ", ") << "{ \"x\" : " << pt.position.x() << ", \"y\" : " << pt.position.y()
                   << ", \"phi\" : " << pt.angle << " }\n";

                // save boundaries
                xMin = xMin <= pt.position.x() ? xMin : pt.position.x();
                xMax = xMax >= pt.position.x() ? xMax : pt.position.x();
                yMin = yMin <= pt.position.y() ? yMin : pt.position.y();
                yMax = yMax >= pt.position.y() ? yMax : pt.position.y();

            }

            os << " ] }\n ";


        }

        // write meta data
        os << R"( ], "meta" : { "xMin" : )" << xMin << ", \"xMax\" : " << xMax
           << ", \"yMin\" : " << yMin << ", \"yMax\" : " << yMax << "  } }";

        return os;

    }

}}
